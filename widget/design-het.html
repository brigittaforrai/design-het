<template id="design-het-widget">
  <link rel="stylesheet" type="text/css" href="widget/styles.css">

  <div class="widget-container">
  </div>

</template>

<script src="p5/p5.js"></script>

<script>
  (function (window, document) {
    let thisDoc = (document._currentScript || document.currentScript).ownerDocument;
    let template = thisDoc.querySelector('template').content;
    if (window.ShadowDOMPolyfill) {
      WebComponents.ShadowCSS.shimStyling(template, 'heat-map');
    }

    class DesignHet extends HTMLElement {
      constructor() {
        super()
        this.widget = null
        this._shadowRoot = null
        this.p5 = null

        this.width = 0
        this.height = 0
        this.cam = null

        this.theta = 0.00
        this.dx = null
        this.xgap = 40
        this.ygap = 40
        this.xNodes = 160
        this.yNodes = 90
        this.nodeSize = 5
        this.length = 3
        this.tempo = 0.1
        this.waveHeight = 10
      }

      connectedCallback () {
        this._shadowRoot = this.attachShadow({ mode: 'open' });
        let clone = document.importNode(template, true);
        this._shadowRoot.appendChild(clone);
        this.widget = this._shadowRoot.querySelector('.widget-container');

        this.p5 = new p5 ((p) => {
          p.setup = () => {
            p.noCanvas()
            this.width = parseInt(window.getComputedStyle(this.widget).width.split('px')[0])
            this.height = parseInt(window.getComputedStyle(this.widget).height.split('px')[0])

            this.xNodes = parseInt(this.width / this.xgap)
            this.yNodes = parseInt(this.height / this.ygap)

            this.canvas = p.createCanvas(this.width, this.height, p.WEBGL)

            this.dx = (p.TWO_PI / 100) * this.length
            this.cam = p.createCamera()
            // ortho([left], [right], [bottom], [top], [near], [far])
            p.ortho(-this.width/2, this.width/2, -this.height/2, this.height/2);
            // p.noLoop()
          }
          p.draw = () => {
            this.draw()
          }
        }, this.widget)

        p5.canvas = this.canvas

        this.addEvents()
      }

      draw() {
        this.p5.background(0);
        this.p5.orbitControl()
        this.theta += this.tempo
        let position = this.grid()
        this.object(position)
      }

      grid () {
        this.p5.noStroke()
        this.p5.fill(250, 10, 100)

        this.p5.translate(-this.width/2, this.height/2, 0)
        let objpos = 0
        let a = this.theta

        for(let x = 0; x<= this.xNodes; x++) {
          for(let z = 0; z<= this.yNodes; z++) {
            this.p5.push()
            this.p5.rotateX(this.p5.HALF_PI)
            // this.p5.rotateY(this.p5.HALF_PI)
            // this.p5.rotateZ(this.p5.HALF_PI)
            let xp = (x * this.xgap)
            let yp = this.p5.sin(a) * this.waveHeight
            let zp = (z * this.ygap)

            this.p5.translate(xp, yp, zp)
            this.p5.sphere(this.nodeSize)
            this.p5.pop()
            if(xp === 250 && zp === 250) {
              objpos = yp
            }
            a += this.dx
          }
        }

        return objpos
      }

      object (pos) {
        this.p5.fill(200,0,0)
        this.p5.push()
        this.p5.translate(250, 250, pos + 10)
        this.p5.rotateZ(this.p5.PI)
        this.p5.cylinder(10, 60);
        this.p5.pop()
      }

      addEvents () {}

      disconnectedCallback () {}
      attributeChangedCallback (attrName, oldval, newVal) {}
    }

    window.customElements.define('design-het', DesignHet);
  })(window, document)
</script>
